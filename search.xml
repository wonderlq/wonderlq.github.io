<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java Instrumentation]]></title>
    <url>%2F2019%2F02%2F01%2FJava-Instrumentation%2F</url>
    <content type="text"><![CDATA[我们在项目调试、统计、监控的时候经常会用到一些工具和指令，比如btrace、jprofile、arthas 等开源工具，比如 jmap、jstack等常用指令。 生产环境也用它们排查问题。那它们的实现原理是什么呢？实际上它们都是使用 java instrument 来实现，大致流程如下： 简单来说是Instrumentation 提供修改类的接口，agent 提供承载Instrumentation的方法。将agent附加于应用程序，就可以实现无入侵修改。 2、详说Instrumentation 和 AgentInstrumentation是java提供的一个接口，提供了一些方法用于查看和操作java类。主要方法如下 ： 方法 说明 void addTransformer(ClassFileTransformer transformer) 注册提供的转换器 long getObjectSize(Object objectToSize) 返回指定类的大小 void retransformClasses(Class&lt;?&gt;… classes) 重转换提供的类集 Class[] getAllLoadedClasses() 获取当前加载的所有类 void appendToBootstrapClassLoaderSearch(JarFile jarfile) 将一个jar加入到bootstrap classloader的 classpath里 我们常用的是 addTransformer 方法，它会注册一个ClassFileTransformer，以后加载的类都会被拦截，ClassFileTransformer 可直接对类字节码进行修改。已经加载过的类，我们可以执行retransformClasses 方法来重新触发ClassFileTransformer转换。 12345678910interface ClassFileTransformer &#123; byte[] transform( ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException;&#125; java agent java agent 是特殊的java程序，它没有main方法，只有premain和agentmain方法。 agent需要依附在一个java程序上，通过Instrumentation API与虚拟机交互。所以agent 与 Instrumentation 是密不可分的。 12345678910111213141516171819202122232425262728293031323334353637//一个简单agent示例public class AgentTest &#123; public static void premain(String agentOpt, Instrumentation inst) &#123; instrument(agentOpt, inst); &#125; public static void agentmain(String agentOpt, Instrumentation inst) &#123; instrument(agentOpt, inst); &#125; private static void instrument(String agentOpt, Instrumentation inst) &#123; inst.addTransformer(new ClassFileTransformer() &#123; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; //在这里可以修改字节码 //返回null表示不对字节码做任何修改 return null; &#125; &#125;); System.out.println(&quot;Agent test&quot;); &#125;&#125;//那 premain 和 agentmain 有什么区别呢？//1、不同的载入方式//* premain是 agent jar包以vm参数附加于普通java应用程序的形式载入;//* agentmain是以attach方式载入 //2、不同的启动时机//* premain 在程序main 方法执行之前执行//* agentmain在java程序启动后执行//3、不同的配置//* premain 的 MANIFEST.MF文件需配置Premain-Class属性//* agentmain 的 MANIFEST.MF文件需配置Agent-Class属性 好了，按照上面的说明，我们只需要自定义一个包含premain或者agentmain 方法的类，然后实现其逻辑，打包时定义MANIFESF.MF文件，就可以实现一个java agent程序。简单的agent demo 加载agent有了一个agent jar包 ，如何将其运行起来发挥作用？agent有两种加载方式：1、启动时加载：配置vm参数 -javaagent:_zzz_xx_yy_.jar2、启动后加载：vm启动后，attach到虚拟机加载12345678String processId = processId();String jarFileName = jarFileName();VirtualMachine virtualMachine = VirtualMachine.attach(processId);try &#123; virtualMachine.loadAgent(jarFileName, &quot;World!&quot;);&#125; finally &#123; virtualMachine.detach();&#125; 对于启动时加载，premain 方法会优先于main 方法执行，所以这是一个可以提前修改加载类的好时机，如果premain方法执行失败或者抛出异常，那么启动就会失败。 对于启动后加载，agentmain 会在加载后执行，如果执行失败或者抛出异常，那么jvm会忽略错误，不会影响程序的正常运行。 3、完整例子 demo 编写需要的agent程序 12 启动agent 12 运行效果 12 4、字节码编辑waiting 5、Attach APIwaiting 6、工具简介7 参考文档]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>agent</tag>
        <tag>Instrumentation</tag>
      </tags>
  </entry>
</search>
