<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[fastjson最佳实践小结]]></title>
    <url>%2Farchives%2F2436c741.html</url>
    <content type="text"><![CDATA[fastjson小结 1、遵循javabean 规范和json规范正确实现setter、getter，用别名就加annotation（ @JSONField(name = “user_name”)） 2、使用正常的key尽量不要使用数字等字符开头的key，尽量使用符合java 的class 或property命名规范的key。例如不要使用a.1这种key 3、尽量使用标准的日期格式序列化和反序列化里都是用相同的dataPattern格式 4、尽量不要用自定义序列化和反序列化除非万不得已，优先考虑使用注解过滤、别名等方式，甚至可以考虑新建一个vo类来组装实际需要的属性。使用自定义序列化千万要小心，改变了pojo–jsonstring的自然对应关系，不利于代码阅读和排查问题；反序列化可能会出错。 5、尽量避免循环引用6、注意编码和不可见字符对于inputstream、outputstream的处理，有时候会报一些奇怪的错误，日志的json字符串正常，但就是报错。这可能就是编码问题，也有可能是utf-8文件的bom头，这些潜在的问题可能在二进制数据转文本的时候，因为一些不可见字符无法显示，导致日志看起来只有正常字符而是正确的，问题很难排查。 使用实例： 1、序列化一个对象成json字符串 123456User user= new User();user.setName(&quot;xiaoMing&quot;);user.setAge(3);String jsonString = JSON.toJSONString(user);System.out.println(jsonString);//&#123;&quot;age&quot;:3,&quot;name&quot;:&quot;xiaoMing&quot;&#125; 2、反序列化一个json串为java对象 123456789String jsonString = &quot;&#123;\&quot;age\&quot;:3,\&quot;birthdate\&quot;:1496738822842,\&quot;name\&quot;:\&quot;校长\&quot;,\&quot;old\&quot;:true,\&quot;salary\&quot;:123456789.0123&#125;&quot;; User u = JSON.parseObject(jsonString ,User.class); System.out.println(u.getName()); // 输出 校长String jsonStringArray = &quot;[&#123;\&quot;age\&quot;:3,\&quot;birthdate\&quot;:1496738822842,\&quot;name\&quot;:\&quot;校长\&quot;,\&quot;old\&quot;:true,\&quot;salary\&quot;:123456789.0123&#125;]&quot;;List&lt;User&gt; userList = JSON.parseArray(jsonStringArray, User.class);System.out.println(userList.size());// 输出 1 3、日志输出格式 123456789101112131415public static class Model &#123; @JSONField(format = &quot;MMM dd, yyyy h:mm:ss aa&quot;) private java.util.Date date; public java.util.Date getDate() &#123; return date; &#125; public void setDate(java.util.Date date) &#123; this.date = date; &#125; @JSONField(format = &quot;MMM-dd-yyyy h:mm:ss aa&quot;) public java.sql.Date date2;&#125; 4、特性设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445QuoteFieldNames, //key使用引号UseSingleQuotes, //使用单引号WriteMapNullValue, //输出Map的null值WriteEnumUsingToString, //枚举属性输出toString的结果WriteEnumUsingName, //枚举数据输出nameUseISO8601DateFormat, //使用日期格式WriteNullListAsEmpty, //List为空则输出[]WriteNullStringAsEmpty, //String为空则输出””WriteNullNumberAsZero, //Number类型为空则输出0WriteNullBooleanAsFalse, //Boolean类型为空则输出falseSkipTransientField,SortField, //排序字段WriteTabAsSpecial,PrettyFormat, // 格式化JSON缩进WriteClassName, // 输出类名DisableCircularReferenceDetect, // 禁止循环引用WriteSlashAsSpecial, // 对斜杠’/’进行转义BrowserCompatible,WriteDateUseDateFormat, // 全局修改日期格式,默认为false。JSON.DEFFAULT_DATE_FORMAT = “yyyy-MM-dd”;JSON.toJSONString(obj, SerializerFeature.WriteDateUseDateFormat);NotWriteRootClassName,DisableCheckSpecialChar,BeanToArray,WriteNonStringKeyAsString,NotWriteDefaultValue,BrowserSecure,IgnoreNonFieldGetter,WriteNonStringValueAsString,IgnoreErrorGetter,WriteBigDecimalAsPlain,MapSortField使用示例如下（可以参见此处）：Word word = new Word();word.setA(&quot;a&quot;);word.setB(2);word.setC(true);word.setD(&quot;d&quot;);word.setE(&quot;&quot;);word.setF(null);word.setDate(new Date());System.out.println(JSON.toJSONString(word));System.out.println(JSON.toJSONString(word, SerializerFeature.PrettyFormat, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty, SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteNullListAsEmpty)); 5、注解使用1) JSONField可以配置在属性（setter、getter）和字段（必须是public field）上。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.alibaba.fastjson.annotation;public @interface JSONField &#123; // 配置序列化和反序列化的顺序，1.1.42版本之后才支持 int ordinal() default 0; // 指定字段的名称 String name() default &quot;&quot;; // 指定字段的格式，对日期格式有用 String format() default &quot;&quot;; // 是否序列化 boolean serialize() default true; // 是否反序列化 boolean deserialize() default true;&#125;@JSONField(name=&quot;ID&quot;)public int getId() &#123;return id;&#125;// 配置date序列化和反序列使用yyyyMMdd日期格式@JSONField(format=&quot;yyyyMMdd&quot;)public Date date1; // 不序列化 @JSONField(serialize=false) public Date date2; // 不反序列化 @JSONField(deserialize=false) public Date date3; // 按ordinal排序 @JSONField(ordinal = 2) private int f1; @JSONField(ordinal = 1) private int f2; 6、object 转map 12345678910111213Map&lt;String, Object&gt; paramsMap = JSON.parseObject(JSON.toJSONString(request));User u = new User();u.setName(&quot;xiaoMing&quot;); Map&lt;String, Object&gt; paramsMap1 = (Map&lt;String, Object&gt;) JSON.toJSON(u); System.out.println(paramsMap1.get(&quot;name&quot;)); //xiaoMing System.out.println(paramsMap1.get(&quot;age&quot;));//null System.out.println(paramsMap1.containsKey(&quot;age&quot;));//true Map&lt;String, Object&gt; paramsMap = JSON.parseObject(JSON.toJSONString(u)); System.out.println(paramsMap.get(&quot;name&quot;));//xiaoMing System.out.println(paramsMap.get(&quot;age&quot;));//null System.out.println(paramsMap.containsKey(&quot;age&quot;));//false 使用(Map&lt;String, Object&gt;) JSON.toJSON(u); 会把空值设置为“null” 字符串，导致异常。所以在转map时，建议使用JSON.parseObject(JSON.toJSONString(u)); 7、使用typereference处理反序列化泛型问题 jsonobject的使用jsonobject是json字符串和pojo对象转换过程中的中间表达类型，==++实现了map接口++==。 可以看作是一个模拟json对象键值对再加上多层嵌套的数据集合，对象的每一个基本属性是map里的一个key-value，一个非基本类型属性是一个嵌套的jsonobject对象（key是属性名称，value是表示这个属性值的对象的jsonobject）。对于jsonstring 转 pojo 或者pojo转jsonstring，尽量使用直接转的方式，而不是先转成jsonobject过渡的方式。对于fastjson，由于性能优化的考虑，这来两个执行的代码是不一样的，可能导致不一样的结果。 123456789String jsonstring = &quot;&#123;\&quot;a\&quot;:12&#125;&quot;;// 不推荐这种方式// 除非这里需要对jsonObject做一些简单处理JSONObject jsonObject = JSON.parseObject(jsonstring);A a = jsonObject.toJavaObject(A.class);// 推荐方式A a = JSON.parseObject(jsonstring, A.class);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>fastjson</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shardbatis的一些问题]]></title>
    <url>%2Farchives%2F1c130d14.html</url>
    <content type="text"><![CDATA[公司项目压测期间，我负责的几个项目要配合支持，在联调过程中，发现一些shardbatis问题。 正文:一、 项目一直用shardbatis做分表，这次压测的改动有涉及到mybatis，会新增加压测的mybatis插件。配置如下： 123456789 &lt;!-- 同时配置 压测插件 和 shardbatis插件 --&gt;&lt;plugins&gt; &lt;!-- 插件：分表 --&gt; &lt;plugin interceptor=&quot;com.google.code.shardbatis.plugin.ShardPlugin&quot;&gt; &lt;property name=&quot;shardingConfig&quot; value=&quot;shard_config.xml&quot; /&gt; &lt;/plugin&gt; &lt;!--插件：压测 --&gt; &lt;plugin interceptor=&quot;com.xxx.pressure.interceptor.MybatisInterceptorXXX&quot;/&gt;&lt;/plugins&gt; 发现压测插件不生效，仔细看代码，它们都配置method = prepare ，导致插件冲突。 123456@Intercepts(&#123;@Signature( type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123;Connection.class&#125;)&#125;)public class ShardPlugin implements Interceptor &#123;...&#125; 所以解决办法及时 将两个插件整合在一起。 二、 插件整合后，对项目进行压测。发现一些查询接口查不出数据，打印sql，发现sql中limit offset语句有问题。 一个原始的的sql语句：SELECT id FROM user_info WHERE age &gt; #{age} LIMIT #{pageSize} OFFSET #{limitStart} 最终执行的却是：SELECT id FROM user_info WHERE age &gt; #{age} LIMIT #{pageSize} , #{limitStart} 这样肯定查不出数据，囧，插件的问题反馈给插件开发的同学，最后得到的回复是： 他们使用了druid的开源sql修改工具，不支持limit offset，所以建议原始sql不要用limit y offset x，要求使用 limit x,y 到底是不是druid的锅，我没有验证，但既然他们要求改，那就改吧。但又引发了第三个问题。 三、 按照建议，原始sql改成了 limit x,y 的语法，压测流量没问题，回归测试时，正常流量却出现 和 2 一样的问题：一些查询接口查不出数据。哦豁这就有意思了。老办法打出执行的sql。 发现 一个原始的的sql语句：SELECT id FROM user_info WHERE age &gt; #{age} LIMIT #{limitStart} , #{pageSize} 最终执行的却是：SELECT id FROM user_info WHERE age &gt; #{age} LIMIT #{limitStart} OFFSET #{pageSize} 正常流量不会经过压测插件的修改流程，只会走shardbatis的修改流程。shardbatis 使用的是 net.sf.jsqlparser开源工具修改sql12345 &lt;dependency&gt; &lt;groupId&gt;net.sf.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.8.0&lt;/version&gt;&lt;/dependency&gt; 追溯源码，找到net.sf.jsqlparser.statement.select.Limit ,发现实现如下12345678910public String toString() &#123; String retVal = &quot;&quot;; if (rowCount &gt; 0 || rowCountJdbcParameter ) &#123; retVal += &quot; LIMIT &quot;+(rowCountJdbcParameter?&quot;?&quot;:rowCount+&quot;&quot;); &#125; if (offset &gt; 0 || offsetJdbcParameter) &#123; retVal += &quot; OFFSET &quot;+(offsetJdbcParameter?&quot;?&quot;:offset+&quot;&quot;); &#125; return retVal; &#125; 最后输出的sql会执行tostring()方法，这里可以看到，最后只会有两种结果limit x 或者 limit x offset y。 所以解决方法就有两种： 硬编码，在业务代码里区分压测流量和正常流量，如果是压测流量就走压测sql：limit x ，y ；如果是正常流量就走正常sql：limit y offset x 更换 net.sf.jsqlparser jar包，net.sf.jsqlparser最新的维护时间是2012年，实在太老旧了。在github上有一个活跃的 com.github.jsqlparser ，应该可以作为替换（但是我们没有采用，毕竟是基础又重要的组件，如果替换，需要花费大量时间精力验证能否正确解析修改sql） 其实google已经不再维护shardbatis了，也无法找到公开的shardbatis jar，只在github 上找到一个历史rep 。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>shardbatis</tag>
        <tag>limit</tag>
        <tag>offset</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Instrumentation]]></title>
    <url>%2Farchives%2Fa9d6e545.html</url>
    <content type="text"><![CDATA[我们在项目调试、排查问题、性能监控的时候经常会用到一些开源工具，比如btrace、jprofile、arthas。今天这篇文章就带你了解下这些工具背后的实现原理：Java Instrumentation 1、Java Instrumentation Instrument是jvm 提供的一个可以修改已加载类的类库，专门为java语言提供的插桩服务提供支持。 使用 Instrumentation，可以替换和修改某些类的定义、向classLoader的classpath下加入jar文件等。我们构建一个独立于应用程序的代理程序（Agent），进而实现Java程序的监控分析，甚至实现一些特殊功能（如AOP、热部署）。 Instrumentation 类有常用的方法： 方法 说明 void addTransformer(ClassFileTransformer transformer) 注册提供的转换器 long getObjectSize(Object objectToSize) 返回指定类的大小 void retransformClasses(Class&lt;?&gt;… classes) 重转换提供的类集 Class[] getAllLoadedClasses() 获取当前加载的所有类 void appendToBootstrapClassLoaderSearch(JarFile jarfile) 将一个jar加入到bootstrap classloader的 classpath里 removeTransformer 移除转换器 redefineClasses 重定义class，会stw 我们常用的是 addTransformer 方法，它会注册一个ClassFileTransformer，在ClassFileTransformer 里可以直接对指定类的类字节码进行修改。通常来说，一般使用ASM,CGLIB,Byte Buddy,Javassist等框架进行字节码增强。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 实现一个自己的 ClassFileTransformer * 使用Javassist给指定的类和方法添加执行时间 */@Slf4jpublic class MyTransformer implements ClassFileTransformer &#123; private String targetClassName; private ClassLoader targetClassLoader; public AtmTransformer(String name, ClassLoader classLoader) &#123; this.targetClassName = name; this.targetClassLoader = classLoader; &#125; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) &#123; byte[] byteCode = classfileBuffer; String finalTargetClassName = this.targetClassName.replaceAll(&quot;\\.&quot;, &quot;/&quot;); if (!className.equals(finalTargetClassName)) &#123; return byteCode; &#125; if (className.equals(finalTargetClassName) &amp;&amp; loader.equals(targetClassLoader)) &#123; log.info(&quot;[Agent] Transforming class&quot;); try &#123; ClassPool cp = ClassPool.getDefault(); CtClass cc = cp.get(targetClassName); CtMethod m = cc.getDeclaredMethod(TARGET_METHOD); m.addLocalVariable(&quot;startTime&quot;, CtClass.longType); m.insertBefore(&quot;startTime = System.currentTimeMillis();&quot;); StringBuilder endBlock = new StringBuilder(); m.addLocalVariable(&quot;endTime&quot;, CtClass.longType); m.addLocalVariable(&quot;opTime&quot;, CtClass.longType); endBlock.append(&quot;endTime = System.currentTimeMillis();&quot;); endBlock.append(&quot;opTime = endTime-startTime;&quot;); endBlock.append(&quot;LOGGER.info(\&quot;[Application] operation completed in:&quot; + &quot;\&quot; + opTime + \&quot; ms!\&quot;);&quot;); m.insertAfter(endBlock.toString()); byteCode = cc.toBytecode(); cc.detach(); &#125; catch (NotFoundException | CannotCompileException | IOException e) &#123; log.error(&quot;Exception&quot;, e); &#125; &#125; return byteCode; &#125;&#125; 2、Java Agent上面的例子在ClassFileTransformer 里实现对字节码的增强，此时我们需要通过Java Agent 拿到一个Instrumentation实例，来实现增强的功能。 Java Agent是一种特殊的jar文件，它是Instrumentation的客户端。根据不同的启动时机，Agent类需要实现不同的方法（二选一）。1234//静态加载public static void premain(String agentArgs, Instrumentation inst);//动态加载public static void agentmain(String agentArgs, Instrumentation inst); 方法 说明 pemain 静态加载 以vm参数的形式载入。在程序main方法执行之前执行。其jar包的manifest需要配置属性Premain-Class。如果premain方法执行失败或者抛出异常，那么启动就会失败。 agentmain 动态加载 以Attach的方式载入，在Java程序启动后执行。其jar包的manifest需要配置属性Agent-Class。如果执行失败或者抛出异常，那么jvm会忽略错误，不会影响程序的正常运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 实现一个自己的 Agent */@Sl4jpublic class AgentTest &#123; public static void premain(String agentArgs, Instrumentation inst) &#123; log.info(&quot;[Agent] In premain method&quot;); String className = &quot;com.example.test.Base&quot;; transformClass(className, inst); &#125; public static void agentmain(String agentArgs, Instrumentation inst) &#123; log.info(&quot;[Agent] In agentmain method&quot;); String className = &quot;com.example.test.Base&quot;; transformClass(className, inst); &#125; private static void transformClass(String className, Instrumentation instrumentation) &#123; Class&lt;?&gt; targetCls = null; ClassLoader targetClassLoader = null; try &#123; targetCls = Class.forName(className); targetClassLoader = targetCls.getClassLoader(); transform(targetCls, targetClassLoader, instrumentation); return; &#125; catch (Exception ex) &#123; LOGGER.error(&quot;Class [&#123;&#125;] not found with Class.forName&quot;); &#125; for (Class&lt;?&gt; clazz : instrumentation.getAllLoadedClasses()) &#123; if (clazz.getName().equals(className)) &#123; targetCls = clazz; targetClassLoader = targetCls.getClassLoader(); transform(targetCls, targetClassLoader, instrumentation); return; &#125; &#125; throw new RuntimeException(&quot;Failed to find class [&quot; + className + &quot;]&quot;); &#125; private static void transform(Class&lt;?&gt; clazz, ClassLoader classLoader, Instrumentation instrumentation) &#123; MyTransformer dt = new MyTransformer(clazz.getName(), classLoader); instrumentation.addTransformer(dt, true); //增加自己的ClassFileTransformer try &#123; instrumentation.retransformClasses(clazz); &#125; catch (Exception ex) &#123; throw new RuntimeException(&quot;Transform failed for: [&quot; + clazz.getName() + &quot;]&quot;, ex); &#125; &#125;&#125; manifest配置则可以参考123456789101112131415&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifestEntries&gt; &lt;Premain-Class&gt;com.example.test.AgentTest&lt;/Premain-Class&gt; &lt;Agent-Class&gt;com.example.test.AgentTest&lt;/Agent-Class&gt; &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt; &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; 按照上述步骤实现了Agent后，需要打出Agent jar包。然后看你是需要静态加载还是动态加载。 静态加载：使用vm参数（如java -javaagent:agent.jar -jar application.jar）跟随宿主程序一起启动 动态加载：使用 jvm attach机制启动 3、Attach机制1234567//使用例子VirtualMachine vm = VirtualMachine.attach(&quot;52341&quot;); //JVM进程pidtry &#123; vm.loadAgent(&quot;.../agent.jar&quot;); // 指定agent的jar包路径，发送给目标进程&#125; finally &#123; vm.detach();&#125; VirtualMachine.attach动作类似TCP创建连接的三次握手，目的就是与target VM搭建attach通信的连接。而后面执行的操作，例如vm.loadAgent，其实就是向这个socket写入数据流，接收方target VM会针对不同的传入数据来做不同的处理。 上述代码里在vm.loadAgent之后，相应的agent就会被目标JVM进程加载，并执行agentmain方法。 Attach API不仅仅可以实现动态加载agent,它其实是跨JVM进程通讯的工具，能够将某种指令从一个JVM进程发送给另一个JVM进程。加载agent只是Attach API发送的各种指令中的一种， 诸如jstack打印线程栈、jps列出Java进程、jmap做内存dump等功能，都属于Attach API可以发送的指令。这里有一篇详细讲述 java attach 的文章，值得阅读下。 4、JVMTIJVMTI =JVM Tool Interface是JVM提供的一套对JVM进行操作的native编程接口。JVMTI是实现Java调试器，以及其它Java运行态测试与分析工具的基础。 通过JVMTI可以实现对JVM的多种操作，然后通过接口注册各种事件勾子。在JVM事件触发时，同时触发预定义的勾子，以实现对各个JVM事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC开始和结束、方法调用进入和退出、临界区竞争与等待、VM启动与退出等等 javaagent 也是基于JVMTI实现，借助JVMTI的一部分能力，帮助动态重载类信息 5、相关技术的实际应用Arthas 是Alibaba开源的Java诊断工具。提供了非常强大功能。Arthas能做什么?Arthas官方文档里面是这样说的：123456这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！是否有一个全局视角来查看系统的运行状况？有什么办法可以监控到JVM的实时运行状态？ 除了官方文档里面提到的这几点，它还能对方法的入参、出参进行监控，记录方法内部调用路径，执行耗时，还有死锁、jar包冲突、占用CUP过大的线程分析等问题。 这是Arthas的一张说明图。 可以看出就是对Instrumentation的实际应用。一些技术细节 例如类加载的隔离值得研究学习。这个项目已经在github开源，相关文档和教程也很丰富（Arthas。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>agent</tag>
        <tag>Instrumentation</tag>
      </tags>
  </entry>
</search>
